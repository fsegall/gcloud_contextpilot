import os
import logging
from typing import Dict, Any

# Assuming these base classes and services exist in the project structure
from back_end.app.agents.base_agent import Agent
from back_end.app.services.pubsub_service import PubSubService
from back_end.app.services.firestore_service import FirestoreService
from back_end.app.services.gemini_service import GeminiService

logger = logging.getLogger(__name__)

class SpecAgent(Agent):
    """
    The SpecAgent is responsible for generating detailed specifications,
    requirements, and validation criteria for tasks and features within
    the ContextPilot project. It listens for requests that require clear
    definitions and leverages the Gemini AI model to assist in generating
    comprehensive and actionable specifications.

    This agent addresses the retrospective feedback regarding idle agents
    and the need for clear specifications for development tasks.
    """

    AGENT_ID = "spec"
    # Pub/Sub topics for incoming specification requests and outgoing responses
    SPEC_REQUEST_TOPIC = os.getenv("PUBSUB_TOPIC_SPEC_REQUEST", "contextpilot.agent.spec.request")
    SPEC_RESPONSE_TOPIC = os.getenv("PUBSUB_TOPIC_SPEC_RESPONSE", "contextpilot.agent.spec.response")

    def __init__(self, pubsub_service: PubSubService, firestore_service: FirestoreService, gemini_service: GeminiService):
        """
        Initializes the SpecAgent with necessary service clients.

        Args:
            pubsub_service: An instance of PubSubService for message brokering.
            firestore_service: An instance of FirestoreService for data persistence.
            gemini_service: An instance of GeminiService for AI content generation.
        """
        super().__init__(self.AGENT_ID, pubsub_service, firestore_service)
        self.gemini_service = gemini_service
        logger.info(f"SpecAgent initialized with ID: {self.AGENT_ID}")

    def _subscribe_to_events(self):
        """
        Subscribes the SpecAgent to relevant Pub/Sub topics.
        This method is called by the base Agent's `start()` method.
        """
        logger.info(f"SpecAgent subscribing to topic: {self.SPEC_REQUEST_TOPIC}")
        # The PubSubService.subscribe method is expected to handle async callbacks
        self.pubsub_service.subscribe(self.SPEC_REQUEST_TOPIC, self.handle_spec_request)

    async def handle_spec_request(self, message_data: Dict[str, Any]):
        """
        Handles incoming messages on the SPEC_REQUEST_TOPIC.
        Processes the request, generates specifications using the Gemini model,
        persists the specification in Firestore, and publishes the result.

        Args:
            message_data: A dictionary containing the message payload.
                          Expected keys:
                            - 'task_id': Unique identifier for the task requiring specs.
                            - 'description': A natural language description of the task/feature.
                            - 'context': Optional, additional context (e.g., code snippets, error logs).
                            - 'requester_agent_id': The ID of the agent that initiated the request.
        """
        task_id = message_data.get("task_id")
        description = message_data.get("description")
        context = message_data.get("context", {})
        requester_agent_id = message_data.get("requester_agent_id", "unknown")

        if not task_id or not description:
            logger.error(f"Invalid spec request received: Missing 'task_id' or 'description'. Data: {message_data}")
            # Optionally publish an error response for malformed requests
            await self._publish_error_response(task_id, "Missing task_id or description", requester_agent_id)
            return

        logger.info(f"SpecAgent received spec request for task_id: {task_id} from {requester_agent_id}")

        try:
            # Construct a detailed prompt for the Gemini model
            prompt = self._construct_gemini_prompt(description, context)
            
            # Generate specifications using Gemini
            gemini_response = await self.gemini_service.generate_content(prompt)
            
            # Extract the generated specification text. Assuming Gemini returns a structured object.
            spec_details = gemini_response.text if gemini_response and gemini_response.text else "No detailed specifications could be generated by AI."

            # Store the generated specification in Firestore for persistence and traceability
            await self.firestore_service.add_document(
                collection_name="specifications",
                document_id=task_id, # Use task_id as document ID for easy lookup
                data={
                    "task_id": task_id,
                    "description": description,
                    "context": context,
                    "spec_details": spec_details,
                    "generated_at": self.firestore_service.get_timestamp(),
                    "status": "generated",
                    "requester_agent_id": requester_agent_id,
                    "agent_id": self.AGENT_ID,
                }
            )

            # Publish the generated specification back to a response topic
            response_payload = {
                "task_id": task_id,
                "status": "success",
                "spec_details": spec_details,
                "requester_agent_id": requester_agent_id,
                "agent_id": self.AGENT_ID,
                "timestamp": self.firestore_service.get_timestamp(),
            }
            await self.pubsub_service.publish(self.SPEC_RESPONSE_TOPIC, response_payload)
            logger.info(f"SpecAgent successfully generated and published spec for task_id: {task_id}")

        except Exception as e:
            logger.error(f"Error processing spec request for task_id {task_id}: {e}", exc_info=True)
            await self._publish_error_response(task_id, str(e), requester_agent_id)

    async def _publish_error_response(self, task_id: str, error_message: str, requester_agent_id: str):
        """
        Helper method to publish an error response to the SPEC_RESPONSE_TOPIC.
        """
        error_payload = {
            "task_id": task_id,
            "status": "error",
            "error_message": error_message,
            "requester_agent_id": requester_agent_id,
            "agent_id": self.AGENT_ID,
            "timestamp": self.firestore_service.get_timestamp(),
        }
        await self.pubsub_service.publish(self.SPEC_RESPONSE_TOPIC, error_payload)

    def _construct_gemini_prompt(self, description: str, context: Dict[str, Any]) -> str:
        """
        Constructs a detailed prompt for the Gemini model to generate a technical specification.
        The prompt guides the AI to produce structured and actionable output.

        Args:
            description: The primary description of the task or feature.
            context: Additional contextual information relevant to the task.

        Returns:
            A string representing the prompt for the Gemini model.
        """
        prompt_parts = [
            "You are an expert software architect and technical writer for the ContextPilot project.",
            "Your task is to generate a detailed technical specification for the following development task.",
            "Provide clear, concise, and actionable requirements, acceptance criteria, and potential implementation considerations.",
            "Focus on clarity for a development team.",
            f"\n--- Task Description ---\n{description}\n",
        ]

        if context:
            prompt_parts.append("\n--- Additional Context ---\n")
            for key, value in context.items():
                prompt_parts.append(f"- {key}: {value}")
            prompt_parts.append("\n")

        prompt_parts.append("\n--- Specification Structure ---\n")
        prompt_parts.append("Please structure your response with the following sections, using Markdown formatting:")
        prompt_parts.append("1.  **Feature/Task Name:** [A short, descriptive name for the task/feature]")
        prompt_parts.append("2.  **Overview:** [A brief summary of the task/feature, its purpose, and value]")
        prompt_parts.append("3.  **Requirements:**")
        prompt_parts.append("    *   **Functional Requirements:** [List what the system *must do* to achieve the task. Use bullet points.]")
        prompt_parts.append("    *   **Non-Functional Requirements:** [e.g., performance, security, scalability, usability, maintainability. Use bullet points.]")
        prompt_parts.append("4.  **Acceptance Criteria:** [Specific, measurable, achievable, relevant, time-bound (SMART) conditions that must be met for the task to be considered complete and successful. Use bullet points, e.g., 'GIVEN X WHEN Y THEN Z'.]")
        prompt_parts.append("5.  **Technical Considerations:** [Outline potential architectural impacts, API changes, database schema modifications, external dependencies, specific technologies, or known challenges. Use bullet points.]")
        prompt_parts.append("6.  **Validation/Testing Strategy:** [Suggest approaches or specific tests to verify the correct implementation of the specification. Use bullet points.]")
        prompt_parts.append("\nEnsure the specification is comprehensive, unambiguous, and directly actionable for a Python development team working on Cloud Run, Firestore, and Pub/Sub.")

        return "\n".join(prompt_parts)