name: Apply ContextPilot Proposals

on:
  repository_dispatch:
    types: [proposal-approved]
  workflow_dispatch:
    inputs:
      proposal_id:
        description: "Proposal ID to apply"
        required: true
        type: string
      workspace_id:
        description: "Workspace ID that owns the proposal"
        required: false
        type: string

jobs:
  apply-proposal:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PERSONAL_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "ContextPilot Bot"
          git config user.email "bot@contextpilot.ai"

      - name: Get proposal ID
        id: proposal
        run: |
          if [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            echo "proposal_id=${{ github.event.client_payload.proposal_id }}" >> $GITHUB_OUTPUT
            echo "workspace_id=${{ github.event.client_payload.workspace_id || 'contextpilot' }}" >> $GITHUB_OUTPUT
          else
            echo "proposal_id=${{ github.event.inputs.proposal_id }}" >> $GITHUB_OUTPUT
            echo "workspace_id=${{ github.event.inputs.workspace_id || 'contextpilot' }}" >> $GITHUB_OUTPUT
          fi

      - name: Fetch proposal from Firestore
        id: fetch
        run: |
          PROPOSAL_ID="${{ steps.proposal.outputs.proposal_id }}"
          WORKSPACE_ID="${{ steps.proposal.outputs.workspace_id }}"
          if [ -z "$WORKSPACE_ID" ] || [ "$WORKSPACE_ID" = "null" ]; then
            WORKSPACE_ID="contextpilot"
          fi
          API_URL="https://contextpilot-backend-581368740395.us-central1.run.app"

          echo "Fetching proposal: $PROPOSAL_ID"

          # Get proposal from API
          curl -s "${API_URL}/proposals/${PROPOSAL_ID}?workspace_id=${WORKSPACE_ID}" \
            -o proposal.json

          # Check if proposal exists
          if ! jq -e '.id' proposal.json > /dev/null 2>&1; then
            echo "‚ùå Proposal not found or invalid response"
            cat proposal.json
            exit 1
          fi

          # Extract proposal details
          TITLE=$(jq -r '.title' proposal.json)
          STATUS=$(jq -r '.status // "pending"' proposal.json)
          
          # Sanitize title for GitHub Actions output (remove markdown and special chars that break output)
          # Remove markdown bold (**text**), including incomplete patterns like **Priority:** or **text:** 
          TITLE_SANITIZED=$(echo "$TITLE" | \
            sed 's/\*\*[^*]*:\s*\*\*//g' | \
            sed 's/\*\*[^*:]*:\s*//g' | \
            sed 's/\*\*[^*]*\*\*//g' | \
            sed 's/\*\*[[:space:]]*//g' | \
            sed 's/[[:space:]]*\*\*//g' | \
            sed 's/\*\*//g' | \
            tr '\n' ' ' | \
            sed 's/[[:space:]]\{2,\}/ /g' | \
            sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | \
            head -c 200)
          
          # Check if this is a sandbox proposal
          IMPLEMENTATION_TYPE=$(jq -r '.metadata.implementation_type // ""' proposal.json)
          SANDBOX_BRANCH=$(jq -r '.metadata.sandbox_branch // ""' proposal.json)
          IS_SANDBOX="false"
          SANDBOX_REPO=""
          
          if [ "$IMPLEMENTATION_TYPE" = "sandbox" ] || [ -n "$SANDBOX_BRANCH" ]; then
            IS_SANDBOX="true"
            # Extract sandbox repo from proposal or use default
            SANDBOX_REPO=$(jq -r '.metadata.sandbox_repo // "fsegall/contextpilot-sandbox"' proposal.json)
            echo "üîç Detected sandbox proposal: branch=$SANDBOX_BRANCH, repo=$SANDBOX_REPO"
          fi

          # Use sanitized title for output (multiline strings break GitHub Actions output)
          {
            echo "title<<EOF"
            echo "$TITLE_SANITIZED"
            echo "EOF"
          } >> $GITHUB_OUTPUT
          echo "status=$STATUS" >> $GITHUB_OUTPUT
          echo "workspace_id=$WORKSPACE_ID" >> $GITHUB_OUTPUT
          echo "is_sandbox=$IS_SANDBOX" >> $GITHUB_OUTPUT
          echo "sandbox_branch=$SANDBOX_BRANCH" >> $GITHUB_OUTPUT
          echo "sandbox_repo=$SANDBOX_REPO" >> $GITHUB_OUTPUT

          echo "‚úÖ Proposal fetched: $TITLE_SANITIZED (status: $STATUS, sandbox: $IS_SANDBOX)"

      - name: Check if sandbox proposal
        id: sandbox_check
        run: |
          if [ "${{ steps.fetch.outputs.is_sandbox }}" = "true" ]; then
            echo "‚ÑπÔ∏è  This is a sandbox proposal - changes already applied by Dev Agent"
            echo "üì¶ Checking PR status in sandbox repository..."
            echo "skip_apply=true" >> $GITHUB_OUTPUT
          else
            echo "skip_apply=false" >> $GITHUB_OUTPUT
          fi

      - name: Apply changes
        if: steps.sandbox_check.outputs.skip_apply == 'false'
        run: |
          # Check if proposed_changes exists and is not empty
          CHANGES_COUNT=$(jq -r '.proposed_changes | length' proposal.json)
          
          if [ "$CHANGES_COUNT" = "0" ] || [ "$CHANGES_COUNT" = "null" ]; then
            echo "‚ÑπÔ∏è  No proposed changes to apply"
            exit 0
          fi
          
          echo "üìù Applying $CHANGES_COUNT proposed change(s)..."
          
          # Extract proposed changes from proposal
          jq -r '.proposed_changes[] | @json' proposal.json | while read -r change_json; do
            file_path=$(echo "$change_json" | jq -r '.file_path')
            change_type=$(echo "$change_json" | jq -r '.change_type')
            content=$(echo "$change_json" | jq -r '.after')
            
            # Skip empty or invalid file paths
            if [ -z "$file_path" ] || [ "$file_path" = "null" ]; then
              echo "  ‚ö†Ô∏è  Skipping invalid file path"
              continue
            fi
            
            echo "üìÑ Applying $change_type to $file_path"
            
            if [ "$change_type" = "delete" ]; then
              if [ -f "$file_path" ]; then
                rm -f "$file_path"
                echo "  ‚úÖ Deleted: $file_path"
              else
                echo "  ‚ÑπÔ∏è  File not found (already deleted?): $file_path"
              fi
            else
              # Create directory if it doesn't exist
              dir_path=$(dirname "$file_path")
              if [ -n "$dir_path" ] && [ "$dir_path" != "." ]; then
                mkdir -p "$dir_path"
              fi
              
              # Write content to file
              echo "$content" > "$file_path"
              echo "  ‚úÖ Updated: $file_path"
            fi
          done
          
          echo "‚úÖ All changes applied successfully!"

      - name: Handle sandbox proposal
        if: steps.fetch.outputs.is_sandbox == 'true'
        uses: actions/github-script@v7
        env:
          SANDBOX_REPO: ${{ steps.fetch.outputs.sandbox_repo }}
          SANDBOX_BRANCH: ${{ steps.fetch.outputs.sandbox_branch }}
          PROPOSAL_ID: ${{ steps.proposal.outputs.proposal_id }}
          MAIN_REPO_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
        with:
          github-token: ${{ secrets.PERSONAL_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const sandboxRepo = process.env.SANDBOX_REPO.split('/');
            const sandboxOwner = sandboxRepo[0];
            const sandboxRepoName = sandboxRepo[1];
            const sandboxBranch = process.env.SANDBOX_BRANCH;
            const proposalId = process.env.PROPOSAL_ID;

            // Load proposal.json generated in previous step to build Review Request
            let proposal;
            try {
              const raw = fs.readFileSync('proposal.json', 'utf8');
              proposal = JSON.parse(raw);
            } catch (e) {
              core.warning(`Could not load proposal.json for review request: ${e.message}`);
              proposal = {};
            }

            const filesAffected = Array.isArray(proposal.proposed_changes)
              ? proposal.proposed_changes.map(c => `- **${c.file_path}** (${c.change_type})`).join('\n')
              : 'No file details available';

            const diffContent = proposal?.diff?.content ? `\n\n\`\`\`diff\n${proposal.diff.content}\n\`\`\`` : '';

            const reviewRequest = [
              `## Review Request`,
              '',
              `Please review the following proposed changes and advise whether to approve or reject.`,
              '',
              `**Proposal ID:** ${proposal.id || proposalId}`,
              `**Title:** ${proposal.title || '(no title)'} `,
              `**Agent:** ${proposal.agent_id || '(unknown)'}`,
              '',
              `### Files Affected`,
              filesAffected,
              '',
              `### Diff`,
              diffContent || '_Diff not available in proposal payload_',
            ].join('\n');

            core.info(`üîç Checking sandbox repo: ${sandboxOwner}/${sandboxRepoName}, branch: ${sandboxBranch}`);

            // Check if PR already exists in sandbox repo
            const { data: prs } = await github.rest.pulls.list({
              owner: sandboxOwner,
              repo: sandboxRepoName,
              head: `${sandboxOwner}:${sandboxBranch}`,
              state: 'open'
            });

            let sandboxPRNumber = null;
            if (prs.length > 0) {
              sandboxPRNumber = prs[0].number;
              core.info(`‚úÖ PR already exists in sandbox: #${sandboxPRNumber} - ${prs[0].html_url}`);
            } else {
              // Try to create PR in sandbox repo
              try {
                const { data: pr } = await github.rest.pulls.create({
                  owner: sandboxOwner,
                  repo: sandboxRepoName,
                  title: `Apply proposal ${proposalId}`,
                  head: sandboxBranch,
                  base: 'main',
                  body: `This PR was created automatically by ContextPilot.\n\n${reviewRequest}`
                });
                sandboxPRNumber = pr.number;
                core.info(`‚úÖ Created PR in sandbox repo: #${sandboxPRNumber} - ${pr.html_url}`);
              } catch (error) {
                core.warning(`‚ö†Ô∏è Could not create PR in sandbox repo: ${error.message}`);
                core.info(`‚ÑπÔ∏è Changes may already be in branch ${sandboxBranch}. Please create PR manually if needed.`);
              }
            }

            // Create PR from sandbox to main repository
            try {
              const mainRepo = context.repo; // Current repo (main)
              const title = `ü§ñ Dev Agent: ${sandboxBranch.replace('dev-agent/', '')}`;
              const sandboxPRUrl = sandboxPRNumber ? `https://github.com/${sandboxOwner}/${sandboxRepoName}/pull/${sandboxPRNumber}` : `https://github.com/${sandboxOwner}/${sandboxRepoName}/tree/${sandboxBranch}`;
              const body = `## Automated PR from Development Agent
              
              **Branch:** \`${sandboxBranch}\`
              **Agent:** Development Agent (Codespaces Mode)
              **Sandbox PR:** ${sandboxPRUrl}
              **Generated:** ${new Date().toISOString()}
              
              ### Proposal
              Proposal ID: ${proposalId}
              
              ### Changes
              This PR contains automated changes generated by the Development Agent based on retrospective insights.
              
              ${reviewRequest}
              
              ---
              *This PR was automatically created by the ContextPilot Development Agent.*`;

              // Create cross-repo PR: head is sandbox branch, base is main repo
              const head = `${sandboxOwner}:${sandboxBranch}`;
              
              // Create a separate GitHub client for the main repo using the main repo token
              const { Octokit } = require('@octokit/rest');
              const mainRepoToken = process.env.MAIN_REPO_TOKEN;
              const mainRepoClient = new Octokit({ auth: mainRepoToken });
              
              // Check if PR already exists
              const { data: existingPRs } = await mainRepoClient.rest.pulls.list({
                owner: mainRepo.owner,
                repo: mainRepo.repo,
                head: head,
                state: 'open'
              });

              if (existingPRs.length > 0) {
                core.info(`‚úÖ PR already exists to main repo: #${existingPRs[0].number} - ${existingPRs[0].html_url}`);
              } else {
                try {
                  const { data: mainPR } = await mainRepoClient.rest.pulls.create({
                    owner: mainRepo.owner,
                    repo: mainRepo.repo,
                    title: title,
                    head: head,
                    base: 'main',
                    body: body
                  });
                  core.info(`‚úÖ Created PR to main repo: #${mainPR.number} - ${mainPR.html_url}`);
                } catch (error) {
                  if (error.status === 403) {
                    core.warning(`‚ö†Ô∏è Permission denied creating PR. Please ensure:
1. Repository setting "Allow GitHub Actions to create and approve pull requests" is enabled, OR
2. Set PERSONAL_GITHUB_TOKEN secret with a Personal Access Token that has 'repo' and 'workflow' scopes`);
                  }
                  throw error;
                }
              }
            } catch (error) {
              core.warning(`‚ö†Ô∏è Could not create PR to main repo: ${error.message}`);
              core.info(`‚ÑπÔ∏è Sandbox PR exists. You may need to manually create PR from ${sandboxBranch} to main repo.`);
            }

      - name: Commit and push changes to feature branch
        if: steps.fetch.outputs.is_sandbox == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.PERSONAL_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          PROPOSAL_ID="${{ steps.proposal.outputs.proposal_id }}"
          TITLE="${{ steps.fetch.outputs.title }}"
          BRANCH_NAME="cp/proposal-${PROPOSAL_ID}"
          
          # Configure git to use token for authentication
          git remote set-url origin https://${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}.git

          # Check if there are changes
          if git diff --quiet && git diff --cached --quiet; then
            echo "‚ÑπÔ∏è  No changes to commit"
            exit 0
          fi

          # Create/checkout feature branch from main
          git checkout -B "$BRANCH_NAME" origin/main

          # Stage all changes
          git add -A

          # Create commit message
          COMMIT_MSG="feat(contextpilot): ${TITLE}

          Applied by ContextPilot Bot via GitHub Actions.
          Proposal-ID: ${PROPOSAL_ID}
          Automated: true"

          # Commit
          git commit -m "$COMMIT_MSG"

          # Push feature branch
          git push -u origin "$BRANCH_NAME"

          echo "‚úÖ Changes committed and pushed to $BRANCH_NAME!"

      - name: Open Pull Request
        if: steps.fetch.outputs.is_sandbox == 'false'
        uses: actions/github-script@v7
        env:
          BRANCH_NAME: cp/proposal-${{ steps.proposal.outputs.proposal_id }}
        with:
          github-token: ${{ secrets.PERSONAL_GITHUB_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const branch = process.env.BRANCH_NAME;
            const base = 'main';
            const title = `Apply proposal ${branch.replace('cp/proposal-','')}`;
            const body = [
              'This PR was created automatically by ContextPilot.',
              '',
              `Proposal ID: ${branch.replace('cp/proposal-','')}`,
              'Please review the applied changes.'
            ].join('\n');

            // Check if a PR already exists for this branch
            const { data: prs } = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head: `${context.repo.owner}:${branch}`,
              state: 'open'
            });
            if (prs.length > 0) {
              core.info(`PR already exists: #${prs[0].number}`);
              return;
            }

            try {
              const { data: pr } = await github.rest.pulls.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                head: branch,
                base,
                body
              });
              core.info(`Opened PR #${pr.number}`);
            } catch (error) {
              if (error.status === 403) {
                core.warning(`‚ö†Ô∏è Permission denied creating PR. Please ensure:
1. Repository setting "Allow GitHub Actions to create and approve pull requests" is enabled, OR
2. Set GITHUB_TOKEN_PAT secret with a Personal Access Token that has 'repo' and 'workflow' scopes`);
              }
              throw error;
            }

      - name: Update proposal status in Firestore
        if: success()
        run: |
          PROPOSAL_ID="${{ steps.proposal.outputs.proposal_id }}"
          API_URL="https://contextpilot-backend-581368740395.us-central1.run.app"
          COMMIT_HASH=$(git rev-parse HEAD)

          echo "Updating proposal $PROPOSAL_ID with commit hash $COMMIT_HASH"

          # Update proposal with commit hash
          # Note: This would require a new API endpoint to update commit hash
          echo "‚úÖ Commit hash: $COMMIT_HASH"

      - name: Comment on failure
        if: failure()
        run: |
          echo "‚ùå Failed to apply proposal ${{ steps.proposal.outputs.proposal_id }}"
          echo "Check the logs above for details."
